#pragma once
/*
对角矩阵 D
3 0 0 0
0 1 0 0
0 0 -5 0
0 0 0 2

单位矩阵 I
1 0 0 0 
0 1 0 0
0 0 1 0
0 0 0 1

向量作为矩阵使用
行向量 [1 2 3]  
列向量
	   [4
		5
		6]

转置 T
a b c
d e f
g h i
=>
a d g
b e h
c f i

矩阵相乘(中间相等取俩头)
A(rn) B(nc)
rn 4x2(4行2列)
nc 2x5(2行5列)
得出
AB(rc)
rc 4x5(4行5列)

A			B
-3	0		-7	2
5	0.5		4	6

A*B
-3*-7 + 0*4		-3*2 + 0*6
5*-7 + 0.5*4	5*2 + 0.5*6		
=>
21	-6
-33	13

单位矩阵乘法
IM = MI = M

矩阵乘法
AB != BA
(AB)C = A(BC)
k(AB) = (kA)B = A(kB)
(ABC)T = (CT)(BT)(AT)

行向量放左边 列向量放右边
[x y z] * [m11 m12 m13
		   m21 m22 m23
		   m31 m32 m33]
1x3		3x3
[xm11+ym21+zm31 xm12+ym22+zm32 xm13+ym23+zm33]
=> 1x3

[m11 m12 m13    [x
 m21 m22 m23  *	 y
 m31 m32 m33]	 z]

 3x3			3x1
[m11x+m12y+m13z
 m21x+m22y+m23z
 m31x+m32y+m33z]
 => 3x1

若向量v是行向量,矩阵变换(推荐):
vABC
若v是列向量,矩阵变换:
CBAv

DirectX使用的是行向量
OpenGL使用的的列向量(Unity shader中)

-------------------------------------
旋转矩阵(就是坐标轴的旋转)
2d旋转矩阵
x轴 (1,0) -> cos() sin()
y轴 (0,1) -> -sin() cos()
当旋转角度为0时,就是坐标轴 
1	0
0	1

cos() sin()
-sin() cos()
3d旋转矩阵
绕x轴旋转
y轴 (0, 1, 0) -> (0, cos(), sin())
z轴 (0, 0, 1) -> (0, -sin(), cos())
旋转矩阵
1	0	 0
0	cos	 sin
0	-sin cos
绕y轴旋转
x轴 (1, 0, 0) -> (cos(), 0, -sin())
z轴 (0, 0, 1) -> (sin(), 0, cos())
旋转矩阵
cos 0 -sin
0	1	0	
sin 0 cos
绕z轴旋转
x轴 (1, 0, 0) -> (cos(), sin(), 0)
y轴 (0, 1, 0) -> (-sin(), cos(), 0)
旋转矩阵
cos  sin	0
-sin cos	0
0	 0		1
-------------------------------------

-------------------------------------
缩放矩阵
kx	0	0
0	ky	0
0	0	kz

X Y Z

=>
kxX	kyY	kzZ

-------------------------------------

-------------------------------------
投影矩阵
Pxy 
1	0	0
0	1	0
0	0	0
Pxz
1	0	0
0	0	0
0	0	1
Pyz
0	0	0
0	1	0
0	0	1

投影到任意平面
平面以垂直的向量表示一个平面
比如: 0 0 1 可以表示xy构成的平面
Nx	Ny	Nz垂直向量构成的平面的投影矩阵:
1+(0-1)Nx^2	(0-1)NxNy	(0-1)NxNz
(0-1)NxNy	1+(0-1)Ny^2	(0-1)NyNz
(0-1)NxNz	(0-1)NzNy	1+(0-1)Nz^2

-------------------------------------

-------------------------------------
镜像就像照镜子(也叫反射)
任意平面
平面以垂直的向量表示一个平面
比如: 0 0 1 可以表示xy构成的平面
镜像矩阵
1-2Nx^2		-2NxNy	-2NxNz
-2NxNy		1-2Ny^2	-2NyNz
-2NxNz		-2NyNz	1-2Nz^2

-------------------------------------

-------------------------------------
切变
切变矩阵
x方向切变:(用y来切变)
1	0
s	1
y方向切变:(用x来切变)
1	s
0	1

y坐标轴变成s 1,这样图片会倾斜

xy方向切变(用z来切变)
1	0	0
0	1	0
s	t	1

xz方向切变(用y来切变)
1	0	0
s	1	t
0	0	1
0

yz方向切变(用x来切变)
1	s	t
0	1	0
0	0	1
-------------------------------------

-------------------------------------
矩阵是行列式(是一个标量)
|M|	= |m11	m12| = m11*m22 - m12*m21
	  |m21	m22|	
只有方阵才有行列式
|M|	= |m11	m12	 m13| =  m11*m22*m33 + m12*m23*m31 + m21*m32*m13
	  |m21	m22	 m23|   -m13*m22*m31 - m11*m23*m32 - m33*m12*m21
	  |m31	m32	 m33|
					  =  m11(m22*m33 - m23*m32)
					    +m12(m23*m31 - m21*m33)
						+m13(m21*m32 - m22*m31)
-------------------------------------

-------------------------------------
矩阵的逆 矩阵跟矩阵的逆相乘得到单位矩阵
(M-1)表示矩阵的逆 
M*(M-1) = (M-1)*M = I

奇异矩阵(不可逆矩阵)		矩阵行列式为0
非奇异矩阵(可逆矩阵)		矩阵行列式不为0

标准伴随矩阵(adjM)的计算
	M	=	-4		-3		3
			0		2		-2
			1		4		-1
	代数余子式矩阵
	c{11} = +|m22 m23| = 2*-1 -(-2) * 4 = -2+8 = 6;			c{12} = -|m21 m23| = -(0*(-1) - (-2)*1 )= -(2) = -2;
			 |m32 m33|								 	 			 |m31 m33|
	c{21} = -|m12 m13| = -((-3)*(-1) - (3)*4 )= -(-9) = 9;  c{22} = +|m11 m13| = -4*(-1) - 1*3 = 1
			 |m32 m33|												 |m31 m33|
		
adjM	=	C{11}	C{12}	C{13} T(转置)
			C{21}	C{22}	C{23} 
			C{31}	C{32}	C{33}

		=	6		-2		-2	T(转置)
			9		1		13
			0		-8		-8

		=   6		9		0
			-2		1		-8
			-2		13		-8
|M| = -24;
(M-1)(矩阵的逆) = (adjM)(标准伴随矩阵) / |M|(矩阵行列式的模)
			   = (adjM)(标准伴随矩阵)  * -1/24
			   = -1/24	-3/8	0
				 1/12	-1/24	1/3
				 1/12	-13/24	1/3

-------------------------------------


-------------------------------------
正交矩阵(三个向量x,y,z互相垂直)

如果该矩阵是正交矩阵，那么可以用(矩阵的转置)来代替(矩阵的逆)来计算

实际使用中很少去检测是否是正交矩阵，因为也需要花一定时间，还不如直接计算(矩阵的逆)，除非知道是正交矩阵，那么直接使用(矩阵的转置)
3d中，大部分都是使用的正交矩阵

因为
M*(M-1)(矩阵的逆) = I;
如果
M(MT)(矩阵的转置) = I;
那么
(MT)(矩阵的转置) = (M-1)(矩阵的逆)
该矩阵成为正交矩阵
几何解释
1、正交矩阵对我们非常有用,因为很容易计算它的逆矩阵
2、逆矩阵计算很复杂，如果是正交矩阵，就可以避免计算逆矩阵

检测是否是正交矩阵
M*(M-1)(矩阵的逆) = I;
 [m11 m12 m13		[m11 m21 m31		[1	0	0
  m21 m22 m23	*    m12 m22 m32	=	 0	1	0
  m31 m32 m33]       m13 m23 m33]		 0	0	1]	
  令M为
   [-r1-
	-r2-
	-r3-]
	r1 = m11 m12 m13
	r2 = m21 m22 m23
	r3 = m31 m32 m33
	则
	1(r1*r1)	0(r1*r2)	0(r1*r3)
	0(r2*r1)	1(r2*r2)	0(r2*r3)
	0(r3*r1)	0(r3*r2)	1(r3*r3)

	0表示垂直
	说明r1,r2,r3互相垂直

矩阵正交化(因为在实际使用中，因为浮点缘故，向量正交性可能有一点偏差，这个时候要使用正交修正)
r1' = r1
r2' = r2 - (r1'*r2) * r1'
r3' = r3 - (r1'*r3) * r1' - (r2'*r3) * r2'
但r1如果一直不变，还是会有偏差，就出现了令一个方案
r1' = r1 - k*(r1*r2)*r2 - k*(r1*r3)*r3
r2' = r2 - k*(r1*r2)*r1 - k*(r2*r3)*r3
r3' = r3 - k*(r1*r3)*r1 - k*(r2*r3)*r2
k是小数，按照这个公式计算个10次就行了

-------------------------------------

-------------------------------------
4x4 齐次矩阵
 [m11 m12 m13		[m11 m12 m13 0			
  m21 m22 m23	=>	 m21 m22 m23 0
  m31 m32 m33]		 m31 m32 m33 0
					  0	  0	  0  1]
 此时向量
 [x	 y	z  1]

 相乘得到
 [xm11+ym21+zm31	xm12+ym22+zm32  xm13+ym23+zm33  1]

 平移矩阵(T)
  					[1 0 0 0
  [x   y   z  1] *	 0 1 0 0
 					 0 0 1 0
					 X Y Z 1]
  [x+X y+Y z+Z 1]		

  线性变换(R)
  [r11	r12	r13	0
   r21	r22	r23	0
   r31	r32	r33	0
   0	0	0	1]

  线性变换跟平移合二为一(相乘)得到
  [r11	r12	r13	0
   r21	r22	r23	0
   r31	r32	r33	0
   X	Y	Z	1]
-------------------------------------

*/
#include "MathUtil.h"

//Vector3声明(类似包含头文件)
class Vector3;

class  Matrix4x3
{
public:
	float m11, m12, m13;
	float m21, m22, m23;
	float m31, m32, m33;
	float tx, ty, tz;
	Matrix4x3() {}

	void setRotate(int axis, float theta);

	void setScale(const float kx, const float ky, const float kz);
	void setScale(const Vector3 &scale);
	//投影
	void setProject(const Vector3 &n);
	//反射(镜像)
	void setReflect(int axis,float k);
	void setReflect(const Vector3 &reflect);
	//切变
	void setShear(int axis, float s, float t);
	//平移
	void zeroTranslation();
	void setTranslation(const Vector3 &t);
	void setUpTranslation(const Vector3 &t);

};
//矩阵乘法
Matrix4x3 operator *(const Matrix4x3 &a, const Matrix4x3 &b);
Matrix4x3 operator *(const Matrix4x3 &m, const float v);
//矩阵跟向量乘法
Vector3 operator *(const Vector3 &v, const Matrix4x3 &m);
Vector3& operator *=(Vector3 &v, const Matrix4x3 &m);
Matrix4x3& operator *=(Matrix4x3 &a, const Matrix4x3 &b);
//矩阵行列式的值
float determinant(const Matrix4x3 &m);
//矩阵的转置
Matrix4x3 transpose(const Matrix4x3 &m);
//矩阵的逆
Matrix4x3 inverse(const Matrix4x3 &m);

//平移
Vector3 getTranslation(const Matrix4x3 &m);